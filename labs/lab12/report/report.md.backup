---
## Front matter
title: "Отчёт по лабораторной работе №12"
subtitle: "Средства, применяемые при разработке программного обеспечения в ОС типа UNIX/Linux"
author: "Цыганков Александр Романович, НПМБВ-02-20"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

# Задание

1. В домашнем каталоге создайте подкаталог ~/work/os/lab_prog.
2. Создайте в нём файлы: calculate.h, calculate.c, main.c. Это будет примитивнейший калькулятор, способный складывать, вычитать, умножать и делить, возводить число в степень, брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать первое число, операцию, второе число. После этого программа выведет результат и остановится.
3. Выполните компиляцию программы посредством gcc.
4. При необходимости исправьте синтаксические ошибки.
5. Создайте Makefile со следующим содержанием.
6. С помощью gdb выполните отладку программы calcul (перед использованием gdb исправьте Makefile)
7. С помощью утилиты splint попробуйте проанализировать коды файлов calculate.c и main.c.

# Теоретическое введение

- Процесс разработки программного обеспечения обычно разделяется на следующие этапы:
	- планирование, включающее сбор и анализ требований к функционалу и другим характеристикам разрабатываемого приложения;
	- проектирование, включающее в себя разработку базовых алгоритмов и спецификаций,
	- определение языка программирования;
	- непосредственная разработка приложения;
		- кодирование - по сути создание исходного текста программы (возможно в нескольких вариантах);
		- анализ разработанного кода;
		- сборка, компиляция и разработка исполняемого модуля;
		- тестирование и отладка, сохранение произведённых изменений;
	- документирование.

Для создания исходного текста программы разработчик может воспользоваться любым удобным для него редактором текста: vi, vim, mceditor, emacs, geany и др. 

После завершения написания исходного кода программы (возможно состоящей из нескольких файлов), необходимо её скомпилировать и получить исполняемый модуль. 

Стандартным средством для компиляции программ в ОС типа UNIX является GCC (GNU Compiler Collection). Это набор компиляторов для разного рода языков программирования (С, C++, Java, Фортран и др.). Работа с GCC производится при помощи одноимённой управляющей программы gcc, которая интерпретирует аргументы командной строки, определяет и осуществляет запуск нужного компилятора для входного файла. 

Файлы с расширением (суффиксом) .c воспринимаются gcc как программы на языке С, файлы с расширением .cc или .C - как файлы на языке C++, а файлы c расширением .o считаются объектными.

# Выполнение лабораторной работы

1. В домашнем каталоге создайте подкаталог ~/work/os/lab_prog. (рис. @fig:001)
	- ![Создание каталога](image/1.png){#fig:001 width=70%}

2. Создайте в нём файлы: calculate.h, calculate.c, main.c. Это будет примитивнейший калькулятор, способный складывать, вычитать, умножать и делить, возводить число в степень, брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать первое число, операцию, второе число. После этого программа выведет результат и остановится. (рис. @fig:002, @fig:003, @fig:004).
	- ![calculate.c](image/2.png){#fig:002 width=70%}
	- ![calculate.h](image/3.png){#fig:003 width=70%}
	- ![main.c](image/4.png){#fig:004 width=70%}

3. Выполните компиляцию программы посредством gcc. (рис. @fig:005)
	- ![Попытка компиляции](image/5.png){#fig:005 width=70%}
	
4. При необходимости исправьте синтаксические ошибки (рис. @fig:006) 
	- ![main.c убрал & перед Operation](image/5.png){#fig:006 width=70%}

5. Создайте Makefile (рис. @fig:007) 
	- ![Компиляция](image/6.png){#fig:007 width=70%}
	- Объяснение файла: 
	
	```
	#Объявление переменных
	CC = gcc # компилятор
	CFLAGS = -g # информацию об отладке помещает в бинарный файл
	LIBS = -lm
	#Создание файл calcul из файлов calculate.o main.o
	calcul: calculate.o main.o 
    	gcc calculate.o main.o -o calcul $(LIBS) 
	#Создание файл calculate.o
	calculate.o: calculate.c calculate.h 
	    -c calculate.c $(CFLAGS) 
	#Создание файл main.o
	main.o: main.c calculate.h #gcc -c main.c -g
    	-c main.c $(CFLAGS) 
	clean: 
		-rm calcul *.o *~  #при вызове make clean будем удалять все файлы с разрешением .о
	```

6. С помощью gdb выполните отладку программы calcul (перед использованием gdb исправьте Makefile) (рис. @fig:008, @fig:009, @fig:010) 
	- ![Запуск программы](image/8.png){#fig:008 width=70%}
	- ![Работа программы](image/10.png){#fig:009 width=70%}
	- ![break, info, ...](image/11.png){#fig:010 width=70%}


7. С помощью утилиты splint попробуйте проанализировать коды файлов calculate.c и main.c (рис. @fig:011, @fig:012)
	- ![splint calculate.c](image/12.png){#fig:011 width=70%}
	- ![splint main.c](image/13.png){#fig:012 width=70%}


# Контрольные вопросы

1. Как получить информацию о возможностях программ gcc, make, gdb и др.?
	- с помощью функций info и man.

2. Назовите и дайте краткую характеристику основным этапам разработки приложений в UNIX. 
	- Unix поддерживает следующие основные этапы разработки приложений:
		- планирование, включающее сбор и анализ требований к функционалу и другим характеристикам разрабатываемого приложения;
		- проектирование, включающее в себя разработку базовых алгоритмов и спецификаций,
		- определение языка программирования;
		- непосредственная разработка приложения;
			- кодирование - по сути создание исходного текста программы (возможно в нескольких вариантах);
			- анализ разработанного кода;
			- сборка, компиляция и разработка исполняемого модуля;
			- тестирование и отладка, сохранение произведённых изменений;
		- документирование.

3. Что такое суффикс в контексте языка программирования? Приведите примеры использования. 
	- В контексте языков программирования, суффикс - это часть имени переменной или значения, которая добавляется к базовому имени или значению, чтобы указать определенный тип, формат или свойство.
	- Примеры использования суффиксов:
		- В C/C++ суффиксы могут использоваться для указания типа литералов. Например, 42 - это целочисленный литерал, а 42.0 - литерал типа с плавающей точкой. В этом случае .0 является суффиксом, указывающим на тип данных. Еще один пример в C/C++ - использование суффиксов f или F для указания типа данных float. Например: 3.14f.
		- В Python суффиксы используются для обозначения размерности числовых литералов. Например, 10_000_000 - это целочисленный литерал, а 10.5 - литерал типа с плавающей точкой. В этом случае .5 является суффиксом. В Python 3.6 и более поздних версиях суффиксы также могут использоваться для указания типа переменных при использовании типовых подсказок. Например, x: int = 10 указывает, что переменная x имеет тип int.
	- В общем, суффиксы в языках программирования используются для явного указания типа данных или свойства значения, что облегчает чтение кода и предотвращает ошибки типов данных.

4. Каково основное назначение компилятора языка С в UNIX? 
	- Основное назначение компилятора с языка Си заключается в компиляции всей программы в целом и получении исполняемого модуля.


5. Для чего предназначена утилита make? 
	- При разработке большой программы, состоящей из нескольких исходных файлов заголовков, приходится постоянно следить за файлами, которые требуют перекомпиляции после внесения изменений. Программа make освобождает пользователя от такой рутинной работы и служит для документирования взаимосвязей между файлами. Описание взаимосвязей и соответствующих действий хранится в так называемом make-файле, который по умолчанию имеет имя makefile или Makefile. 


6. Приведите пример структуры Makefile. Дайте характеристику основным элементам этого файла. 

	``#Компилятор  ``
	
	``CC=gcc``
	
	``#Флаги компилятора``
	
	``CFLAGS=-I.``
	
	``#Имя исполняемого файла``
	
	``TARGET=myprogram``
	
	``#Список исходных файлов``
	
	``SOURCES=main.c func1.c func2.c``
	
	``#Генерация объектных файлов``
	
	``OBJECTS=$(SOURCES:.c=.o)``
	
	``#Команда по умолчанию``
	
	``all: $(TARGET)``
	
	``#Сборка исполняемого файла из объектных файлов``
	
	``$(TARGET): $(OBJECTS)``
	
		``$(CC) -o $(TARGET) $(OBJECTS)``
		
	``#Компиляция каждого исходного файла в объектный файл``
	``.c.o:``
	
		``$(CC) $(CFLAGS) -c $< -o $@``
		
	``#Очистка временных файлов``
	
	``clean:``
	
		``rm -f $(OBJECTS) $(TARGET)``
	- В этом примере:
		- Компилятор и флаги компиляции:
        		- CC - переменная, определяющая используемый компилятор (в данном случае gcc).
        		- CFLAGS - переменная, определяющая флаги компилятора (в данном случае -I. добавляет текущий каталог в список каталогов для поиска заголовочных файлов).
    - Имя цели (target):
       	- TARGET - переменная, определяющая имя исполняемого файла (в данном случае myprogram).
    - Список исходных файлов:
        - SOURCES - переменная, содержащая список исходных файлов (в данном случае main.c, func1.c, func2.c).
    - Генерация объектных файлов:
        - OBJECTS - переменная, содержащая список объектных файлов, получаемых из исходных файлов (.c файлы заменяются на .o).
    - Команда по умолчанию:
        - all - указывает, что цель myprogram должна быть создана по умолчанию при вызове make без аргументов.
    - Правила сборки:
        - $(TARGET) - правило для создания исполняемого файла из объектных файлов.
        - .c.o - правило для компиляции каждого .c файла в объектный .o файл.
    - Очистка временных файлов:
        - clean - правило для удаления временных файлов (используется для очистки проекта от объектных файлов и исполняемого файла).



7. Назовите основное свойство, присущее всем программам отладки. Что необходимо сделать, чтобы его можно было использовать?
	- Пошаговая отладка программ заключается в том, что выполняется один оператор программы и, затем контролируются те переменные, на которые должен был воздействовать данный оператор. Если в программе имеются уже отлаженные подпрограммы, то подпрограмму можно рассматривать, как один оператор программы и воспользоваться вторым способом отладки программ. Если в программе существует достаточно большой участок программы, уже отлаженный ранее, то его можно выполнить, не контролируя переменные, на которые он воздействует. Использование точек останова позволяет пропускать уже отлаженную часть программы. Точка останова устанавливается в местах, где необходимо проверить содержимое переменных или просто проконтролировать, передаётся ли управление данному оператору. Практически во всех отладчиках поддерживается это свойство (а также выполнение программы до курсора и выход из подпрограммы). Затем отладка программы продолжается в пошаговом режиме с контролем локальных и глобальных переменных, а также внутренних регистров микроконтроллера и напряжений на выводах этой микросхемы.


8. Назовите и дайте основную характеристику основным командам отладчика gdb.
	- backtrace - выводит весь путь к текущей точке останова, то есть названия всех функций, начиная от main(); иными словами, выводит весь стек функций;
	- break - устанавливает точку останова; параметром может быть номер строки или название функции;
	- clear - удаляет все точки останова на текущем уровне стека (то есть в текущей функции);
	- continue - продолжает выполнение программы от текущей точки до конца;
	- delete - удаляет точку останова или контрольное выражение;
	- display - добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы;
	- finish - выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется;
	- info breakpoints - выводит список всех имеющихся точек останова;
	- info watchpoints - выводит список всех имеющихся контрольных выражений;
	- splist - выводит исходный код; в качестве параметра передаются название файла исходного кода, затем, через двоеточие, номер начальной и конечной строки;
	- next - пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции;
	- print - выводит значение какого-либо выражения (выражение передаётся в качестве параметра);
	- run - запускает программу на выполнение;
	- set - устанавливает новое значение переменной
	- step - пошаговое выполнение программы;
	- watch - устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится;

9. Опишите по шагам схему отладки программы, которую Вы использовали при выполнении лабораторной работы. 
	- Выполнили компиляцию программы 
	- Не удалось скомпилировать - ошибки 
	- Исправили ошибки
	- Запустили отладчик gdb, отладчик выполнил программу, ввели требуемые значения, программа выполнилась без ошибок.

10. Прокомментируйте реакцию компилятора на синтаксические ошибки в программе при его первом запуске. 
	- Отладчик выдал ошибку в строке с %s, &Operation, %s - символьный формат, убрали & перед Operation.

11. Назовите основные средства, повышающие понимание исходного кода программы. 
	- cscope - исследование функций, содержащихся в программе
	- splint - критическая проверка программ, написанных на языке Си.

12. Каковы основные задачи, решаемые программой splint?
	- Выявление ошибок в коде: Splint анализирует исходный код на предмет типичных ошибок программирования, таких как доступ к памяти через нулевой указатель, разыменование непроверенного указателя, переполнение буфера, утечки памяти и другие.
	- Поиск потенциальных проблем безопасности: Splint способен обнаруживать уязвимости безопасности, такие как возможные атаки типа "buffer overflow", "format string vulnerabilities", "race conditions" и другие.
	- Проверка соответствия стандартам кодирования: Splint может проверять код на соответствие различным стандартам кодирования и соглашениям о стиле написания кода, таким как MISRA C, POSIX, GNU и другим.
	- Анализ потока управления и данных: Splint проводит анализ потока управления и данных в коде для выявления потенциальных проблем с безопасностью и логикой программы.
	- Поддержка статических типов данных: Splint помогает выявлять ошибки и несоответствия типов данных в программе, что способствует предотвращению некоторых типов ошибок времени выполнения.
	- Улучшение читаемости кода: Splint предоставляет рекомендации по улучшению стиля кодирования и читаемости программы, что делает код более понятным и поддерживаемым.


# Выводы

В ходе выполнения лабораторной работы я приобрел простейшие навыки разработки и отладки приложений в ОС типа UNIX/Linux на примере создания на языке С калькулятора с простейшими функциями.

# Список литературы{.unnumbered}

1. Практикум по лабораторной работе

::: {#refs}
:::